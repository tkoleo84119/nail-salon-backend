package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"sort"
	"strings"
)

type ErrorDefinition struct {
	Code    string `json:"code"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

func main() {
	var inputPath string
	var outputPath string
	flag.StringVar(&inputPath, "input", "", "path to errors.json")
	flag.StringVar(&outputPath, "output", "", "path to generate codes.go")
	flag.Parse()

	if inputPath == "" || outputPath == "" {
		fmt.Fprintln(os.Stderr, "usage: gen_codes -input=errors.json -output=codes.go")
		os.Exit(2)
	}

	data, err := os.ReadFile(inputPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to read %s: %v\n", inputPath, err)
		os.Exit(1)
	}

	var categories map[string]map[string]ErrorDefinition
	if err := json.Unmarshal(data, &categories); err != nil {
		fmt.Fprintf(os.Stderr, "failed to parse JSON: %v\n", err)
		os.Exit(1)
	}

	// Preferred category order to keep file stable
	preferredOrder := []string{
		"AUTH", "VAL", "BOOKING", "CUSTOMER", "SCHEDULE", "SERVICE", "STAFF", "STORE", "STYLIST", "TIME_SLOT", "SYS",
	}

	// Collect actual categories
	var catList []string
	for cat := range categories {
		catList = append(catList, cat)
	}

	// Sort categories by preferred order; unknowns go to the end alphabetically
	orderIndex := map[string]int{}
	for i, c := range preferredOrder {
		orderIndex[c] = i
	}
	sort.Slice(catList, func(i, j int) bool {
		ai, aok := orderIndex[catList[i]]
		aj, bok := orderIndex[catList[j]]
		switch {
		case aok && bok:
			return ai < aj
		case aok:
			return true
		case bok:
			return false
		default:
			return catList[i] < catList[j]
		}
	})

	// Start generating file
	f, err := os.Create(outputPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to create %s: %v\n", outputPath, err)
		os.Exit(1)
	}
	defer f.Close()

	write := func(format string, a ...any) {
		if _, err := fmt.Fprintf(f, format, a...); err != nil {
			fmt.Fprintf(os.Stderr, "write error: %v\n", err)
			os.Exit(1)
		}
	}

	write("package errors\n\n")
	write("// Code generated by go generate; DO NOT EDIT.\n")
	write("// Source: %s\n\n", inputPath)
	write("// Error codes constants for easy reference\n")
	write("const (\n")

	for _, cat := range catList {
		write("\t// %s - %s related errors\n", cat, strings.ToLower(strings.ReplaceAll(cat, "_", " ")))
		// Collect keys and sort for stability
		var keys []string
		for k := range categories[cat] {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			constName := k
			write("\t%s = \"%s\"\n", constName, k)
		}
		write("\n")
	}

	write(")\n")
}
