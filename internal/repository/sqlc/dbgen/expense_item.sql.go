// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: expense_item.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BatchCreateExpenseItemsParams struct {
	ID              int64              `db:"id" json:"id"`
	ExpenseID       int64              `db:"expense_id" json:"expense_id"`
	ProductID       int64              `db:"product_id" json:"product_id"`
	Quantity        int32              `db:"quantity" json:"quantity"`
	Price           pgtype.Numeric     `db:"price" json:"price"`
	ExpirationDate  pgtype.Date        `db:"expiration_date" json:"expiration_date"`
	IsArrived       pgtype.Bool        `db:"is_arrived" json:"is_arrived"`
	ArrivalDate     pgtype.Date        `db:"arrival_date" json:"arrival_date"`
	StorageLocation pgtype.Text        `db:"storage_location" json:"storage_location"`
	Note            pgtype.Text        `db:"note" json:"note"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

const checkExpenseItemsExistsByExpenseID = `-- name: CheckExpenseItemsExistsByExpenseID :one
SELECT EXISTS(SELECT 1 FROM expense_items WHERE expense_id = $1)
`

func (q *Queries) CheckExpenseItemsExistsByExpenseID(ctx context.Context, expenseID int64) (bool, error) {
	row := q.db.QueryRow(ctx, checkExpenseItemsExistsByExpenseID, expenseID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createStoreExpenseItem = `-- name: CreateStoreExpenseItem :exec
INSERT INTO expense_items (
    id,
    expense_id,
    product_id,
    quantity,
    price,
    expiration_date,
    is_arrived,
    arrival_date,
    storage_location,
    note
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
`

type CreateStoreExpenseItemParams struct {
	ID              int64          `db:"id" json:"id"`
	ExpenseID       int64          `db:"expense_id" json:"expense_id"`
	ProductID       int64          `db:"product_id" json:"product_id"`
	Quantity        int32          `db:"quantity" json:"quantity"`
	Price           pgtype.Numeric `db:"price" json:"price"`
	ExpirationDate  pgtype.Date    `db:"expiration_date" json:"expiration_date"`
	IsArrived       pgtype.Bool    `db:"is_arrived" json:"is_arrived"`
	ArrivalDate     pgtype.Date    `db:"arrival_date" json:"arrival_date"`
	StorageLocation pgtype.Text    `db:"storage_location" json:"storage_location"`
	Note            pgtype.Text    `db:"note" json:"note"`
}

func (q *Queries) CreateStoreExpenseItem(ctx context.Context, arg CreateStoreExpenseItemParams) error {
	_, err := q.db.Exec(ctx, createStoreExpenseItem,
		arg.ID,
		arg.ExpenseID,
		arg.ProductID,
		arg.Quantity,
		arg.Price,
		arg.ExpirationDate,
		arg.IsArrived,
		arg.ArrivalDate,
		arg.StorageLocation,
		arg.Note,
	)
	return err
}

const getStoreExpenseItemByID = `-- name: GetStoreExpenseItemByID :one
SELECT
    id,
    expense_id,
    product_id,
    quantity,
    price,
    expiration_date,
    is_arrived,
    arrival_date,
    storage_location,
    note
FROM expense_items
WHERE id = $1
AND expense_id = $2
`

type GetStoreExpenseItemByIDParams struct {
	ID        int64 `db:"id" json:"id"`
	ExpenseID int64 `db:"expense_id" json:"expense_id"`
}

type GetStoreExpenseItemByIDRow struct {
	ID              int64          `db:"id" json:"id"`
	ExpenseID       int64          `db:"expense_id" json:"expense_id"`
	ProductID       int64          `db:"product_id" json:"product_id"`
	Quantity        int32          `db:"quantity" json:"quantity"`
	Price           pgtype.Numeric `db:"price" json:"price"`
	ExpirationDate  pgtype.Date    `db:"expiration_date" json:"expiration_date"`
	IsArrived       pgtype.Bool    `db:"is_arrived" json:"is_arrived"`
	ArrivalDate     pgtype.Date    `db:"arrival_date" json:"arrival_date"`
	StorageLocation pgtype.Text    `db:"storage_location" json:"storage_location"`
	Note            pgtype.Text    `db:"note" json:"note"`
}

func (q *Queries) GetStoreExpenseItemByID(ctx context.Context, arg GetStoreExpenseItemByIDParams) (GetStoreExpenseItemByIDRow, error) {
	row := q.db.QueryRow(ctx, getStoreExpenseItemByID, arg.ID, arg.ExpenseID)
	var i GetStoreExpenseItemByIDRow
	err := row.Scan(
		&i.ID,
		&i.ExpenseID,
		&i.ProductID,
		&i.Quantity,
		&i.Price,
		&i.ExpirationDate,
		&i.IsArrived,
		&i.ArrivalDate,
		&i.StorageLocation,
		&i.Note,
	)
	return i, err
}

const getStoreExpenseItemsByExpenseID = `-- name: GetStoreExpenseItemsByExpenseID :many
SELECT
    ei.id,
    ei.product_id,
    p.name AS product_name,
    ei.quantity,
    ei.price,
    ei.expiration_date,
    ei.is_arrived,
    ei.arrival_date,
    ei.storage_location,
    ei.note
FROM expense_items ei
LEFT JOIN products p ON ei.product_id = p.id
WHERE ei.expense_id = $1
`

type GetStoreExpenseItemsByExpenseIDRow struct {
	ID              int64          `db:"id" json:"id"`
	ProductID       int64          `db:"product_id" json:"product_id"`
	ProductName     pgtype.Text    `db:"product_name" json:"product_name"`
	Quantity        int32          `db:"quantity" json:"quantity"`
	Price           pgtype.Numeric `db:"price" json:"price"`
	ExpirationDate  pgtype.Date    `db:"expiration_date" json:"expiration_date"`
	IsArrived       pgtype.Bool    `db:"is_arrived" json:"is_arrived"`
	ArrivalDate     pgtype.Date    `db:"arrival_date" json:"arrival_date"`
	StorageLocation pgtype.Text    `db:"storage_location" json:"storage_location"`
	Note            pgtype.Text    `db:"note" json:"note"`
}

func (q *Queries) GetStoreExpenseItemsByExpenseID(ctx context.Context, expenseID int64) ([]GetStoreExpenseItemsByExpenseIDRow, error) {
	rows, err := q.db.Query(ctx, getStoreExpenseItemsByExpenseID, expenseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStoreExpenseItemsByExpenseIDRow{}
	for rows.Next() {
		var i GetStoreExpenseItemsByExpenseIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ProductName,
			&i.Quantity,
			&i.Price,
			&i.ExpirationDate,
			&i.IsArrived,
			&i.ArrivalDate,
			&i.StorageLocation,
			&i.Note,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
