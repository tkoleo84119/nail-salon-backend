// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: schedule.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BatchCreateSchedulesParams struct {
	ID        int64              `db:"id" json:"id"`
	StoreID   int64              `db:"store_id" json:"store_id"`
	StylistID int64              `db:"stylist_id" json:"stylist_id"`
	WorkDate  pgtype.Date        `db:"work_date" json:"work_date"`
	Note      pgtype.Text        `db:"note" json:"note"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

const checkScheduleCanUpdateDate = `-- name: CheckScheduleCanUpdateDate :one
SELECT NOT EXISTS(
    SELECT 1
    FROM time_slots ts
    WHERE ts.schedule_id = $1
    AND (
        ts.is_available = false
        OR (
            ts.is_available = true
            AND EXISTS (
                SELECT 1
                FROM bookings b
                WHERE b.time_slot_id = ts.id
                AND b.status IN ('CANCELLED', 'NO_SHOW')
            )
        )
    )
) as can_update
`

func (q *Queries) CheckScheduleCanUpdateDate(ctx context.Context, scheduleID int64) (bool, error) {
	row := q.db.QueryRow(ctx, checkScheduleCanUpdateDate, scheduleID)
	var can_update bool
	err := row.Scan(&can_update)
	return can_update, err
}

const checkScheduleDateExists = `-- name: CheckScheduleDateExists :one
SELECT EXISTS(
    SELECT 1 FROM schedules
    WHERE store_id = $1 AND stylist_id = $2 AND work_date = $3
) as exists
`

type CheckScheduleDateExistsParams struct {
	StoreID   int64       `db:"store_id" json:"store_id"`
	StylistID int64       `db:"stylist_id" json:"stylist_id"`
	WorkDate  pgtype.Date `db:"work_date" json:"work_date"`
}

func (q *Queries) CheckScheduleDateExists(ctx context.Context, arg CheckScheduleDateExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkScheduleDateExists, arg.StoreID, arg.StylistID, arg.WorkDate)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkScheduleExistsByID = `-- name: CheckScheduleExistsByID :one
SELECT EXISTS(
    SELECT 1 FROM schedules
    WHERE id = $1
) as exists
`

func (q *Queries) CheckScheduleExistsByID(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, checkScheduleExistsByID, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkSchedulesCanDelete = `-- name: CheckSchedulesCanDelete :many
SELECT
    s.id,
    s.store_id,
    s.stylist_id,
    s.work_date,
    NOT EXISTS(
        SELECT 1
        FROM time_slots ts
        WHERE ts.schedule_id = s.id
        AND (
            ts.is_available = false
            OR (
                ts.is_available = true
                AND EXISTS (
                    SELECT 1
                    FROM bookings b
                    WHERE b.time_slot_id = ts.id
                    AND b.status IN ('CANCELLED', 'NO_SHOW')
                )
            )
        )
    ) as can_delete
FROM schedules s
WHERE s.id = ANY($1::bigint[])
`

type CheckSchedulesCanDeleteRow struct {
	ID        int64       `db:"id" json:"id"`
	StoreID   int64       `db:"store_id" json:"store_id"`
	StylistID int64       `db:"stylist_id" json:"stylist_id"`
	WorkDate  pgtype.Date `db:"work_date" json:"work_date"`
	CanDelete bool        `db:"can_delete" json:"can_delete"`
}

func (q *Queries) CheckSchedulesCanDelete(ctx context.Context, dollar_1 []int64) ([]CheckSchedulesCanDeleteRow, error) {
	rows, err := q.db.Query(ctx, checkSchedulesCanDelete, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CheckSchedulesCanDeleteRow{}
	for rows.Next() {
		var i CheckSchedulesCanDeleteRow
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.StylistID,
			&i.WorkDate,
			&i.CanDelete,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteSchedulesByIDs = `-- name: DeleteSchedulesByIDs :exec
DELETE FROM schedules
WHERE id = ANY($1::bigint[])
`

func (q *Queries) DeleteSchedulesByIDs(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, deleteSchedulesByIDs, dollar_1)
	return err
}

const getAvailableSchedules = `-- name: GetAvailableSchedules :many
SELECT s.id, s.work_date
FROM schedules s
JOIN time_slots ts ON s.id = ts.schedule_id
WHERE s.store_id = $1
  AND s.stylist_id = $2
  AND s.work_date BETWEEN $3 AND $4
  AND ts.is_available = true
GROUP BY s.id, s.work_date
ORDER BY s.work_date ASC
`

type GetAvailableSchedulesParams struct {
	StoreID    int64       `db:"store_id" json:"store_id"`
	StylistID  int64       `db:"stylist_id" json:"stylist_id"`
	WorkDate   pgtype.Date `db:"work_date" json:"work_date"`
	WorkDate_2 pgtype.Date `db:"work_date_2" json:"work_date_2"`
}

type GetAvailableSchedulesRow struct {
	ID       int64       `db:"id" json:"id"`
	WorkDate pgtype.Date `db:"work_date" json:"work_date"`
}

func (q *Queries) GetAvailableSchedules(ctx context.Context, arg GetAvailableSchedulesParams) ([]GetAvailableSchedulesRow, error) {
	rows, err := q.db.Query(ctx, getAvailableSchedules,
		arg.StoreID,
		arg.StylistID,
		arg.WorkDate,
		arg.WorkDate_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailableSchedulesRow{}
	for rows.Next() {
		var i GetAvailableSchedulesRow
		if err := rows.Scan(&i.ID, &i.WorkDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduleByID = `-- name: GetScheduleByID :one
SELECT
    id,
    store_id,
    stylist_id,
    work_date
FROM schedules
WHERE id = $1
`

type GetScheduleByIDRow struct {
	ID        int64       `db:"id" json:"id"`
	StoreID   int64       `db:"store_id" json:"store_id"`
	StylistID int64       `db:"stylist_id" json:"stylist_id"`
	WorkDate  pgtype.Date `db:"work_date" json:"work_date"`
}

func (q *Queries) GetScheduleByID(ctx context.Context, id int64) (GetScheduleByIDRow, error) {
	row := q.db.QueryRow(ctx, getScheduleByID, id)
	var i GetScheduleByIDRow
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.StylistID,
		&i.WorkDate,
	)
	return i, err
}

const getScheduleWithTimeSlotsByID = `-- name: GetScheduleWithTimeSlotsByID :many
SELECT
    s.id,
    s.work_date,
    s.note,
    t.id as time_slot_id,
    t.start_time,
    t.end_time,
    t.is_available
FROM schedules s
LEFT JOIN time_slots t ON s.id = t.schedule_id
WHERE s.id = $1
ORDER BY t.start_time
`

type GetScheduleWithTimeSlotsByIDRow struct {
	ID          int64       `db:"id" json:"id"`
	WorkDate    pgtype.Date `db:"work_date" json:"work_date"`
	Note        pgtype.Text `db:"note" json:"note"`
	TimeSlotID  pgtype.Int8 `db:"time_slot_id" json:"time_slot_id"`
	StartTime   pgtype.Time `db:"start_time" json:"start_time"`
	EndTime     pgtype.Time `db:"end_time" json:"end_time"`
	IsAvailable pgtype.Bool `db:"is_available" json:"is_available"`
}

func (q *Queries) GetScheduleWithTimeSlotsByID(ctx context.Context, id int64) ([]GetScheduleWithTimeSlotsByIDRow, error) {
	rows, err := q.db.Query(ctx, getScheduleWithTimeSlotsByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetScheduleWithTimeSlotsByIDRow{}
	for rows.Next() {
		var i GetScheduleWithTimeSlotsByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkDate,
			&i.Note,
			&i.TimeSlotID,
			&i.StartTime,
			&i.EndTime,
			&i.IsAvailable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
