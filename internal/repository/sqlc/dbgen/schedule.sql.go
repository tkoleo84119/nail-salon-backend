// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: schedule.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BatchCreateSchedulesParams struct {
	ID        int64              `db:"id" json:"id"`
	StoreID   int64              `db:"store_id" json:"store_id"`
	StylistID int64              `db:"stylist_id" json:"stylist_id"`
	WorkDate  pgtype.Date        `db:"work_date" json:"work_date"`
	Note      pgtype.Text        `db:"note" json:"note"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

const checkScheduleExists = `-- name: CheckScheduleExists :one
SELECT EXISTS(
    SELECT 1 FROM schedules
    WHERE store_id = $1 AND stylist_id = $2 AND work_date = $3
) as exists
`

type CheckScheduleExistsParams struct {
	StoreID   int64       `db:"store_id" json:"store_id"`
	StylistID int64       `db:"stylist_id" json:"stylist_id"`
	WorkDate  pgtype.Date `db:"work_date" json:"work_date"`
}

func (q *Queries) CheckScheduleExists(ctx context.Context, arg CheckScheduleExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkScheduleExists, arg.StoreID, arg.StylistID, arg.WorkDate)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createSchedule = `-- name: CreateSchedule :one
INSERT INTO schedules (
    id,
    store_id,
    stylist_id,
    work_date,
    note,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, NOW(), NOW()
) RETURNING
    id,
    store_id,
    stylist_id,
    work_date,
    note,
    created_at,
    updated_at
`

type CreateScheduleParams struct {
	ID        int64       `db:"id" json:"id"`
	StoreID   int64       `db:"store_id" json:"store_id"`
	StylistID int64       `db:"stylist_id" json:"stylist_id"`
	WorkDate  pgtype.Date `db:"work_date" json:"work_date"`
	Note      pgtype.Text `db:"note" json:"note"`
}

func (q *Queries) CreateSchedule(ctx context.Context, arg CreateScheduleParams) (Schedule, error) {
	row := q.db.QueryRow(ctx, createSchedule,
		arg.ID,
		arg.StoreID,
		arg.StylistID,
		arg.WorkDate,
		arg.Note,
	)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.StylistID,
		&i.WorkDate,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSchedulesByStoreAndStylist = `-- name: GetSchedulesByStoreAndStylist :many
SELECT
    id,
    store_id,
    stylist_id,
    work_date,
    note,
    created_at,
    updated_at
FROM schedules
WHERE store_id = $1 AND stylist_id = $2
ORDER BY work_date
`

type GetSchedulesByStoreAndStylistParams struct {
	StoreID   int64 `db:"store_id" json:"store_id"`
	StylistID int64 `db:"stylist_id" json:"stylist_id"`
}

func (q *Queries) GetSchedulesByStoreAndStylist(ctx context.Context, arg GetSchedulesByStoreAndStylistParams) ([]Schedule, error) {
	rows, err := q.db.Query(ctx, getSchedulesByStoreAndStylist, arg.StoreID, arg.StylistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Schedule{}
	for rows.Next() {
		var i Schedule
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.StylistID,
			&i.WorkDate,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
