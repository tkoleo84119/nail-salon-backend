// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: schedule.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BatchCreateSchedulesParams struct {
	ID        int64              `db:"id" json:"id"`
	StoreID   int64              `db:"store_id" json:"store_id"`
	StylistID int64              `db:"stylist_id" json:"stylist_id"`
	WorkDate  pgtype.Date        `db:"work_date" json:"work_date"`
	Note      pgtype.Text        `db:"note" json:"note"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

const checkScheduleExists = `-- name: CheckScheduleExists :one
SELECT EXISTS(
    SELECT 1 FROM schedules
    WHERE store_id = $1 AND stylist_id = $2 AND work_date = $3
) as exists
`

type CheckScheduleExistsParams struct {
	StoreID   int64       `db:"store_id" json:"store_id"`
	StylistID int64       `db:"stylist_id" json:"stylist_id"`
	WorkDate  pgtype.Date `db:"work_date" json:"work_date"`
}

func (q *Queries) CheckScheduleExists(ctx context.Context, arg CheckScheduleExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkScheduleExists, arg.StoreID, arg.StylistID, arg.WorkDate)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkScheduleExistsByID = `-- name: CheckScheduleExistsByID :one
SELECT EXISTS(
    SELECT 1 FROM schedules
    WHERE id = $1
) as exists
`

func (q *Queries) CheckScheduleExistsByID(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, checkScheduleExistsByID, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const deleteSchedulesByIDs = `-- name: DeleteSchedulesByIDs :exec
DELETE FROM schedules
WHERE id = ANY($1::bigint[])
`

func (q *Queries) DeleteSchedulesByIDs(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, deleteSchedulesByIDs, dollar_1)
	return err
}

const getAvailableSchedules = `-- name: GetAvailableSchedules :many
SELECT s.id, s.work_date
FROM schedules s
JOIN time_slots ts ON s.id = ts.schedule_id
WHERE s.store_id = $1
  AND s.stylist_id = $2
  AND s.work_date BETWEEN $3 AND $4
  AND ts.is_available = true
GROUP BY s.id, s.work_date
ORDER BY s.work_date ASC
`

type GetAvailableSchedulesParams struct {
	StoreID    int64       `db:"store_id" json:"store_id"`
	StylistID  int64       `db:"stylist_id" json:"stylist_id"`
	WorkDate   pgtype.Date `db:"work_date" json:"work_date"`
	WorkDate_2 pgtype.Date `db:"work_date_2" json:"work_date_2"`
}

type GetAvailableSchedulesRow struct {
	ID       int64       `db:"id" json:"id"`
	WorkDate pgtype.Date `db:"work_date" json:"work_date"`
}

func (q *Queries) GetAvailableSchedules(ctx context.Context, arg GetAvailableSchedulesParams) ([]GetAvailableSchedulesRow, error) {
	rows, err := q.db.Query(ctx, getAvailableSchedules,
		arg.StoreID,
		arg.StylistID,
		arg.WorkDate,
		arg.WorkDate_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailableSchedulesRow{}
	for rows.Next() {
		var i GetAvailableSchedulesRow
		if err := rows.Scan(&i.ID, &i.WorkDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduleByID = `-- name: GetScheduleByID :one
SELECT
    id,
    store_id,
    stylist_id,
    work_date,
    note,
    created_at,
    updated_at
FROM schedules
WHERE id = $1
`

func (q *Queries) GetScheduleByID(ctx context.Context, id int64) (Schedule, error) {
	row := q.db.QueryRow(ctx, getScheduleByID, id)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.StylistID,
		&i.WorkDate,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getScheduleWithTimeSlotsByID = `-- name: GetScheduleWithTimeSlotsByID :many
SELECT
    s.id,
    s.store_id,
    s.stylist_id,
    s.work_date,
    s.note,
    s.created_at,
    s.updated_at,
    t.id as time_slot_id,
    t.start_time,
    t.end_time,
    t.is_available
FROM schedules s
LEFT JOIN time_slots t ON s.id = t.schedule_id
WHERE s.id = $1
ORDER BY t.start_time
`

type GetScheduleWithTimeSlotsByIDRow struct {
	ID          int64              `db:"id" json:"id"`
	StoreID     int64              `db:"store_id" json:"store_id"`
	StylistID   int64              `db:"stylist_id" json:"stylist_id"`
	WorkDate    pgtype.Date        `db:"work_date" json:"work_date"`
	Note        pgtype.Text        `db:"note" json:"note"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	TimeSlotID  pgtype.Int8        `db:"time_slot_id" json:"time_slot_id"`
	StartTime   pgtype.Time        `db:"start_time" json:"start_time"`
	EndTime     pgtype.Time        `db:"end_time" json:"end_time"`
	IsAvailable pgtype.Bool        `db:"is_available" json:"is_available"`
}

func (q *Queries) GetScheduleWithTimeSlotsByID(ctx context.Context, id int64) ([]GetScheduleWithTimeSlotsByIDRow, error) {
	rows, err := q.db.Query(ctx, getScheduleWithTimeSlotsByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetScheduleWithTimeSlotsByIDRow{}
	for rows.Next() {
		var i GetScheduleWithTimeSlotsByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.StylistID,
			&i.WorkDate,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TimeSlotID,
			&i.StartTime,
			&i.EndTime,
			&i.IsAvailable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchedulesWithTimeSlotsByIDs = `-- name: GetSchedulesWithTimeSlotsByIDs :many
SELECT
    s.id,
    s.store_id,
    s.stylist_id,
    s.work_date,
    s.note,
    s.created_at,
    s.updated_at,
    t.id as time_slot_id,
    t.start_time,
    t.end_time,
    t.is_available
FROM schedules s
LEFT JOIN time_slots t ON s.id = t.schedule_id
WHERE s.id = ANY($1::bigint[])
ORDER BY s.work_date
`

type GetSchedulesWithTimeSlotsByIDsRow struct {
	ID          int64              `db:"id" json:"id"`
	StoreID     int64              `db:"store_id" json:"store_id"`
	StylistID   int64              `db:"stylist_id" json:"stylist_id"`
	WorkDate    pgtype.Date        `db:"work_date" json:"work_date"`
	Note        pgtype.Text        `db:"note" json:"note"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	TimeSlotID  pgtype.Int8        `db:"time_slot_id" json:"time_slot_id"`
	StartTime   pgtype.Time        `db:"start_time" json:"start_time"`
	EndTime     pgtype.Time        `db:"end_time" json:"end_time"`
	IsAvailable pgtype.Bool        `db:"is_available" json:"is_available"`
}

func (q *Queries) GetSchedulesWithTimeSlotsByIDs(ctx context.Context, dollar_1 []int64) ([]GetSchedulesWithTimeSlotsByIDsRow, error) {
	rows, err := q.db.Query(ctx, getSchedulesWithTimeSlotsByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSchedulesWithTimeSlotsByIDsRow{}
	for rows.Next() {
		var i GetSchedulesWithTimeSlotsByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.StylistID,
			&i.WorkDate,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TimeSlotID,
			&i.StartTime,
			&i.EndTime,
			&i.IsAvailable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
