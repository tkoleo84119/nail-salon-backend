// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: schedule.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BatchCreateSchedulesParams struct {
	ID        int64              `db:"id" json:"id"`
	StoreID   int64              `db:"store_id" json:"store_id"`
	StylistID int64              `db:"stylist_id" json:"stylist_id"`
	WorkDate  pgtype.Date        `db:"work_date" json:"work_date"`
	Note      pgtype.Text        `db:"note" json:"note"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

const checkScheduleExists = `-- name: CheckScheduleExists :one
SELECT EXISTS(
    SELECT 1 FROM schedules
    WHERE store_id = $1 AND stylist_id = $2 AND work_date = $3
) as exists
`

type CheckScheduleExistsParams struct {
	StoreID   int64       `db:"store_id" json:"store_id"`
	StylistID int64       `db:"stylist_id" json:"stylist_id"`
	WorkDate  pgtype.Date `db:"work_date" json:"work_date"`
}

func (q *Queries) CheckScheduleExists(ctx context.Context, arg CheckScheduleExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkScheduleExists, arg.StoreID, arg.StylistID, arg.WorkDate)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createSchedule = `-- name: CreateSchedule :one
INSERT INTO schedules (
    id,
    store_id,
    stylist_id,
    work_date,
    note,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, NOW(), NOW()
) RETURNING
    id,
    store_id,
    stylist_id,
    work_date,
    note,
    created_at,
    updated_at
`

type CreateScheduleParams struct {
	ID        int64       `db:"id" json:"id"`
	StoreID   int64       `db:"store_id" json:"store_id"`
	StylistID int64       `db:"stylist_id" json:"stylist_id"`
	WorkDate  pgtype.Date `db:"work_date" json:"work_date"`
	Note      pgtype.Text `db:"note" json:"note"`
}

func (q *Queries) CreateSchedule(ctx context.Context, arg CreateScheduleParams) (Schedule, error) {
	row := q.db.QueryRow(ctx, createSchedule,
		arg.ID,
		arg.StoreID,
		arg.StylistID,
		arg.WorkDate,
		arg.Note,
	)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.StylistID,
		&i.WorkDate,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSchedulesByIDs = `-- name: DeleteSchedulesByIDs :exec
DELETE FROM schedules
WHERE id = ANY($1::bigint[])
`

func (q *Queries) DeleteSchedulesByIDs(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, deleteSchedulesByIDs, dollar_1)
	return err
}

const getAvailableSchedules = `-- name: GetAvailableSchedules :many
SELECT s.work_date, COUNT(*) AS available_slots
FROM schedules s
JOIN time_slots ts ON s.id = ts.schedule_id
LEFT JOIN bookings b ON ts.id = b.time_slot_id AND b.status != 'CANCELLED'
WHERE s.store_id = $1
  AND s.stylist_id = $2
  AND s.work_date BETWEEN $3 AND $4
  AND ts.is_available = true
  AND b.id IS NULL
GROUP BY s.work_date
ORDER BY s.work_date ASC
`

type GetAvailableSchedulesParams struct {
	StoreID    int64       `db:"store_id" json:"store_id"`
	StylistID  int64       `db:"stylist_id" json:"stylist_id"`
	WorkDate   pgtype.Date `db:"work_date" json:"work_date"`
	WorkDate_2 pgtype.Date `db:"work_date_2" json:"work_date_2"`
}

type GetAvailableSchedulesRow struct {
	WorkDate       pgtype.Date `db:"work_date" json:"work_date"`
	AvailableSlots int64       `db:"available_slots" json:"available_slots"`
}

func (q *Queries) GetAvailableSchedules(ctx context.Context, arg GetAvailableSchedulesParams) ([]GetAvailableSchedulesRow, error) {
	rows, err := q.db.Query(ctx, getAvailableSchedules,
		arg.StoreID,
		arg.StylistID,
		arg.WorkDate,
		arg.WorkDate_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailableSchedulesRow{}
	for rows.Next() {
		var i GetAvailableSchedulesRow
		if err := rows.Scan(&i.WorkDate, &i.AvailableSlots); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduleByID = `-- name: GetScheduleByID :one
SELECT
    id,
    store_id,
    stylist_id,
    work_date,
    note,
    created_at,
    updated_at
FROM schedules
WHERE id = $1
`

func (q *Queries) GetScheduleByID(ctx context.Context, id int64) (Schedule, error) {
	row := q.db.QueryRow(ctx, getScheduleByID, id)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.StylistID,
		&i.WorkDate,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getScheduleByIDWithTimeSlotsByID = `-- name: GetScheduleByIDWithTimeSlotsByID :many
SELECT
    s.id,
    s.store_id,
    s.stylist_id,
    s.work_date,
    s.note,
    s.created_at,
    s.updated_at,
    t.id as time_slot_id,
    t.start_time,
    t.end_time,
    t.is_available
FROM schedules s
LEFT JOIN time_slots t ON s.id = t.schedule_id
WHERE s.id = $1
`

type GetScheduleByIDWithTimeSlotsByIDRow struct {
	ID          int64              `db:"id" json:"id"`
	StoreID     int64              `db:"store_id" json:"store_id"`
	StylistID   int64              `db:"stylist_id" json:"stylist_id"`
	WorkDate    pgtype.Date        `db:"work_date" json:"work_date"`
	Note        pgtype.Text        `db:"note" json:"note"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	TimeSlotID  pgtype.Int8        `db:"time_slot_id" json:"time_slot_id"`
	StartTime   pgtype.Time        `db:"start_time" json:"start_time"`
	EndTime     pgtype.Time        `db:"end_time" json:"end_time"`
	IsAvailable pgtype.Bool        `db:"is_available" json:"is_available"`
}

func (q *Queries) GetScheduleByIDWithTimeSlotsByID(ctx context.Context, id int64) ([]GetScheduleByIDWithTimeSlotsByIDRow, error) {
	rows, err := q.db.Query(ctx, getScheduleByIDWithTimeSlotsByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetScheduleByIDWithTimeSlotsByIDRow{}
	for rows.Next() {
		var i GetScheduleByIDWithTimeSlotsByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.StylistID,
			&i.WorkDate,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TimeSlotID,
			&i.StartTime,
			&i.EndTime,
			&i.IsAvailable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchedulesByStoreAndStylist = `-- name: GetSchedulesByStoreAndStylist :many
SELECT
    id,
    store_id,
    stylist_id,
    work_date,
    note,
    created_at,
    updated_at
FROM schedules
WHERE store_id = $1 AND stylist_id = $2
ORDER BY work_date
`

type GetSchedulesByStoreAndStylistParams struct {
	StoreID   int64 `db:"store_id" json:"store_id"`
	StylistID int64 `db:"stylist_id" json:"stylist_id"`
}

func (q *Queries) GetSchedulesByStoreAndStylist(ctx context.Context, arg GetSchedulesByStoreAndStylistParams) ([]Schedule, error) {
	rows, err := q.db.Query(ctx, getSchedulesByStoreAndStylist, arg.StoreID, arg.StylistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Schedule{}
	for rows.Next() {
		var i Schedule
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.StylistID,
			&i.WorkDate,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchedulesWithTimeSlotsByIDs = `-- name: GetSchedulesWithTimeSlotsByIDs :many
SELECT
    s.id,
    s.store_id,
    s.stylist_id,
    s.work_date,
    s.note,
    s.created_at,
    s.updated_at,
    t.id as time_slot_id,
    t.start_time,
    t.end_time,
    t.is_available
FROM schedules s
LEFT JOIN time_slots t ON s.id = t.schedule_id
WHERE s.id = ANY($1::bigint[])
ORDER BY s.work_date
`

type GetSchedulesWithTimeSlotsByIDsRow struct {
	ID          int64              `db:"id" json:"id"`
	StoreID     int64              `db:"store_id" json:"store_id"`
	StylistID   int64              `db:"stylist_id" json:"stylist_id"`
	WorkDate    pgtype.Date        `db:"work_date" json:"work_date"`
	Note        pgtype.Text        `db:"note" json:"note"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	TimeSlotID  pgtype.Int8        `db:"time_slot_id" json:"time_slot_id"`
	StartTime   pgtype.Time        `db:"start_time" json:"start_time"`
	EndTime     pgtype.Time        `db:"end_time" json:"end_time"`
	IsAvailable pgtype.Bool        `db:"is_available" json:"is_available"`
}

func (q *Queries) GetSchedulesWithTimeSlotsByIDs(ctx context.Context, dollar_1 []int64) ([]GetSchedulesWithTimeSlotsByIDsRow, error) {
	rows, err := q.db.Query(ctx, getSchedulesWithTimeSlotsByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSchedulesWithTimeSlotsByIDsRow{}
	for rows.Next() {
		var i GetSchedulesWithTimeSlotsByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.StylistID,
			&i.WorkDate,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TimeSlotID,
			&i.StartTime,
			&i.EndTime,
			&i.IsAvailable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
