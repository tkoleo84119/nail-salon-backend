// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: product.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkProductNameBrandExistsInStore = `-- name: CheckProductNameBrandExistsInStore :one
SELECT EXISTS(
    SELECT 1 FROM products
    WHERE store_id = $1 AND name = $2 AND brand_id = $3
)
`

type CheckProductNameBrandExistsInStoreParams struct {
	StoreID int64  `db:"store_id" json:"store_id"`
	Name    string `db:"name" json:"name"`
	BrandID int64  `db:"brand_id" json:"brand_id"`
}

func (q *Queries) CheckProductNameBrandExistsInStore(ctx context.Context, arg CheckProductNameBrandExistsInStoreParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkProductNameBrandExistsInStore, arg.StoreID, arg.Name, arg.BrandID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkProductNameBrandExistsInStoreExcluding = `-- name: CheckProductNameBrandExistsInStoreExcluding :one
SELECT EXISTS(
    SELECT 1 FROM products
    WHERE store_id = $1 AND name = $2 AND brand_id = $3 AND id != $4
)
`

type CheckProductNameBrandExistsInStoreExcludingParams struct {
	StoreID int64  `db:"store_id" json:"store_id"`
	Name    string `db:"name" json:"name"`
	BrandID int64  `db:"brand_id" json:"brand_id"`
	ID      int64  `db:"id" json:"id"`
}

func (q *Queries) CheckProductNameBrandExistsInStoreExcluding(ctx context.Context, arg CheckProductNameBrandExistsInStoreExcludingParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkProductNameBrandExistsInStoreExcluding,
		arg.StoreID,
		arg.Name,
		arg.BrandID,
		arg.ID,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createProduct = `-- name: CreateProduct :exec
INSERT INTO products (
    id,
    store_id,
    name,
    brand_id,
    category_id,
    current_stock,
    safety_stock,
    unit,
    storage_location,
    note
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
`

type CreateProductParams struct {
	ID              int64       `db:"id" json:"id"`
	StoreID         int64       `db:"store_id" json:"store_id"`
	Name            string      `db:"name" json:"name"`
	BrandID         int64       `db:"brand_id" json:"brand_id"`
	CategoryID      int64       `db:"category_id" json:"category_id"`
	CurrentStock    int32       `db:"current_stock" json:"current_stock"`
	SafetyStock     pgtype.Int4 `db:"safety_stock" json:"safety_stock"`
	Unit            pgtype.Text `db:"unit" json:"unit"`
	StorageLocation pgtype.Text `db:"storage_location" json:"storage_location"`
	Note            pgtype.Text `db:"note" json:"note"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) error {
	_, err := q.db.Exec(ctx, createProduct,
		arg.ID,
		arg.StoreID,
		arg.Name,
		arg.BrandID,
		arg.CategoryID,
		arg.CurrentStock,
		arg.SafetyStock,
		arg.Unit,
		arg.StorageLocation,
		arg.Note,
	)
	return err
}

const getProductByID = `-- name: GetProductByID :one
SELECT
    id,
    store_id,
    name,
    brand_id,
    category_id,
    current_stock,
    safety_stock,
    unit,
    storage_location,
    note,
    created_at,
    updated_at
FROM products
WHERE id = $1
`

type GetProductByIDRow struct {
	ID              int64              `db:"id" json:"id"`
	StoreID         int64              `db:"store_id" json:"store_id"`
	Name            string             `db:"name" json:"name"`
	BrandID         int64              `db:"brand_id" json:"brand_id"`
	CategoryID      int64              `db:"category_id" json:"category_id"`
	CurrentStock    int32              `db:"current_stock" json:"current_stock"`
	SafetyStock     pgtype.Int4        `db:"safety_stock" json:"safety_stock"`
	Unit            pgtype.Text        `db:"unit" json:"unit"`
	StorageLocation pgtype.Text        `db:"storage_location" json:"storage_location"`
	Note            pgtype.Text        `db:"note" json:"note"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetProductByID(ctx context.Context, id int64) (GetProductByIDRow, error) {
	row := q.db.QueryRow(ctx, getProductByID, id)
	var i GetProductByIDRow
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.BrandID,
		&i.CategoryID,
		&i.CurrentStock,
		&i.SafetyStock,
		&i.Unit,
		&i.StorageLocation,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductWithDetailsByID = `-- name: GetProductWithDetailsByID :one
SELECT
    p.id,
    p.store_id,
    p.name,
    p.brand_id,
    b.name AS brand_name,
    p.category_id,
    pc.name AS category_name,
    p.current_stock,
    p.safety_stock,
    p.unit,
    p.storage_location,
    p.note,
    p.is_active,
    p.created_at,
    p.updated_at
FROM products p
INNER JOIN brands b ON p.brand_id = b.id
INNER JOIN product_categories pc ON p.category_id = pc.id
WHERE p.id = $1
`

type GetProductWithDetailsByIDRow struct {
	ID              int64              `db:"id" json:"id"`
	StoreID         int64              `db:"store_id" json:"store_id"`
	Name            string             `db:"name" json:"name"`
	BrandID         int64              `db:"brand_id" json:"brand_id"`
	BrandName       string             `db:"brand_name" json:"brand_name"`
	CategoryID      int64              `db:"category_id" json:"category_id"`
	CategoryName    string             `db:"category_name" json:"category_name"`
	CurrentStock    int32              `db:"current_stock" json:"current_stock"`
	SafetyStock     pgtype.Int4        `db:"safety_stock" json:"safety_stock"`
	Unit            pgtype.Text        `db:"unit" json:"unit"`
	StorageLocation pgtype.Text        `db:"storage_location" json:"storage_location"`
	Note            pgtype.Text        `db:"note" json:"note"`
	IsActive        pgtype.Bool        `db:"is_active" json:"is_active"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetProductWithDetailsByID(ctx context.Context, id int64) (GetProductWithDetailsByIDRow, error) {
	row := q.db.QueryRow(ctx, getProductWithDetailsByID, id)
	var i GetProductWithDetailsByIDRow
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.BrandID,
		&i.BrandName,
		&i.CategoryID,
		&i.CategoryName,
		&i.CurrentStock,
		&i.SafetyStock,
		&i.Unit,
		&i.StorageLocation,
		&i.Note,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductsStockInfoByIDs = `-- name: GetProductsStockInfoByIDs :many
SELECT
    id,
    store_id,
    current_stock
FROM products
WHERE id = ANY($1::bigint[])
`

type GetProductsStockInfoByIDsRow struct {
	ID           int64 `db:"id" json:"id"`
	StoreID      int64 `db:"store_id" json:"store_id"`
	CurrentStock int32 `db:"current_stock" json:"current_stock"`
}

func (q *Queries) GetProductsStockInfoByIDs(ctx context.Context, dollar_1 []int64) ([]GetProductsStockInfoByIDsRow, error) {
	rows, err := q.db.Query(ctx, getProductsStockInfoByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductsStockInfoByIDsRow{}
	for rows.Next() {
		var i GetProductsStockInfoByIDsRow
		if err := rows.Scan(&i.ID, &i.StoreID, &i.CurrentStock); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductCurrentStock = `-- name: UpdateProductCurrentStock :exec
UPDATE products
SET current_stock = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateProductCurrentStockParams struct {
	ID           int64 `db:"id" json:"id"`
	CurrentStock int32 `db:"current_stock" json:"current_stock"`
}

func (q *Queries) UpdateProductCurrentStock(ctx context.Context, arg UpdateProductCurrentStockParams) error {
	_, err := q.db.Exec(ctx, updateProductCurrentStock, arg.ID, arg.CurrentStock)
	return err
}
