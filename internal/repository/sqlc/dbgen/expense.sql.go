// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: expense.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkSupplierExists = `-- name: CheckSupplierExists :one
SELECT EXISTS(SELECT 1 FROM suppliers WHERE id = $1 AND is_active = true)
`

func (q *Queries) CheckSupplierExists(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, checkSupplierExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createExpense = `-- name: CreateExpense :one
INSERT INTO expenses (
    id,
    store_id,
    category,
    supplier_id,
    amount,
    other_fee,
    expense_date,
    note,
    payer_id,
    is_reimbursed
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id
`

type CreateExpenseParams struct {
	ID           int64          `db:"id" json:"id"`
	StoreID      int64          `db:"store_id" json:"store_id"`
	Category     pgtype.Text    `db:"category" json:"category"`
	SupplierID   pgtype.Int8    `db:"supplier_id" json:"supplier_id"`
	Amount       pgtype.Numeric `db:"amount" json:"amount"`
	OtherFee     pgtype.Numeric `db:"other_fee" json:"other_fee"`
	ExpenseDate  pgtype.Date    `db:"expense_date" json:"expense_date"`
	Note         pgtype.Text    `db:"note" json:"note"`
	PayerID      pgtype.Int8    `db:"payer_id" json:"payer_id"`
	IsReimbursed pgtype.Bool    `db:"is_reimbursed" json:"is_reimbursed"`
}

func (q *Queries) CreateExpense(ctx context.Context, arg CreateExpenseParams) (int64, error) {
	row := q.db.QueryRow(ctx, createExpense,
		arg.ID,
		arg.StoreID,
		arg.Category,
		arg.SupplierID,
		arg.Amount,
		arg.OtherFee,
		arg.ExpenseDate,
		arg.Note,
		arg.PayerID,
		arg.IsReimbursed,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getStoreExpenseByID = `-- name: GetStoreExpenseByID :one
SELECT
    e.id,
    e.supplier_id,
    COALESCE(s.name, '') AS supplier_name,
    e.payer_id,
    COALESCE(su.username, '') AS payer_name,
    e.category,
    e.amount,
    e.other_fee,
    e.expense_date,
    e.note,
    e.is_reimbursed,
    e.reimbursed_at,
    e.created_at,
    e.updated_at
FROM expenses e
LEFT JOIN suppliers s ON e.supplier_id = s.id
LEFT JOIN staff_users su ON e.payer_id = su.id
WHERE e.id = $1 AND e.store_id = $2
`

type GetStoreExpenseByIDParams struct {
	ID      int64 `db:"id" json:"id"`
	StoreID int64 `db:"store_id" json:"store_id"`
}

type GetStoreExpenseByIDRow struct {
	ID           int64              `db:"id" json:"id"`
	SupplierID   pgtype.Int8        `db:"supplier_id" json:"supplier_id"`
	SupplierName string             `db:"supplier_name" json:"supplier_name"`
	PayerID      pgtype.Int8        `db:"payer_id" json:"payer_id"`
	PayerName    string             `db:"payer_name" json:"payer_name"`
	Category     pgtype.Text        `db:"category" json:"category"`
	Amount       pgtype.Numeric     `db:"amount" json:"amount"`
	OtherFee     pgtype.Numeric     `db:"other_fee" json:"other_fee"`
	ExpenseDate  pgtype.Date        `db:"expense_date" json:"expense_date"`
	Note         pgtype.Text        `db:"note" json:"note"`
	IsReimbursed pgtype.Bool        `db:"is_reimbursed" json:"is_reimbursed"`
	ReimbursedAt pgtype.Timestamptz `db:"reimbursed_at" json:"reimbursed_at"`
	CreatedAt    pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetStoreExpenseByID(ctx context.Context, arg GetStoreExpenseByIDParams) (GetStoreExpenseByIDRow, error) {
	row := q.db.QueryRow(ctx, getStoreExpenseByID, arg.ID, arg.StoreID)
	var i GetStoreExpenseByIDRow
	err := row.Scan(
		&i.ID,
		&i.SupplierID,
		&i.SupplierName,
		&i.PayerID,
		&i.PayerName,
		&i.Category,
		&i.Amount,
		&i.OtherFee,
		&i.ExpenseDate,
		&i.Note,
		&i.IsReimbursed,
		&i.ReimbursedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
