// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: expense.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkSupplierExists = `-- name: CheckSupplierExists :one
SELECT EXISTS(SELECT 1 FROM suppliers WHERE id = $1 AND is_active = true)
`

func (q *Queries) CheckSupplierExists(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, checkSupplierExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createExpense = `-- name: CreateExpense :one
INSERT INTO expenses (
    id,
    store_id,
    category,
    supplier_id,
    amount,
    other_fee,
    expense_date,
    note,
    payer_id,
    is_reimbursed,
    updater
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id
`

type CreateExpenseParams struct {
	ID           int64          `db:"id" json:"id"`
	StoreID      int64          `db:"store_id" json:"store_id"`
	Category     pgtype.Text    `db:"category" json:"category"`
	SupplierID   pgtype.Int8    `db:"supplier_id" json:"supplier_id"`
	Amount       pgtype.Numeric `db:"amount" json:"amount"`
	OtherFee     pgtype.Numeric `db:"other_fee" json:"other_fee"`
	ExpenseDate  pgtype.Date    `db:"expense_date" json:"expense_date"`
	Note         pgtype.Text    `db:"note" json:"note"`
	PayerID      pgtype.Int8    `db:"payer_id" json:"payer_id"`
	IsReimbursed pgtype.Bool    `db:"is_reimbursed" json:"is_reimbursed"`
	Updater      pgtype.Int8    `db:"updater" json:"updater"`
}

func (q *Queries) CreateExpense(ctx context.Context, arg CreateExpenseParams) (int64, error) {
	row := q.db.QueryRow(ctx, createExpense,
		arg.ID,
		arg.StoreID,
		arg.Category,
		arg.SupplierID,
		arg.Amount,
		arg.OtherFee,
		arg.ExpenseDate,
		arg.Note,
		arg.PayerID,
		arg.IsReimbursed,
		arg.Updater,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getExpenseReportByCategory = `-- name: GetExpenseReportByCategory :many
SELECT
    COALESCE(category, '未分類') as category,
    COUNT(*) as count,
    COALESCE(SUM(amount + COALESCE(other_fee, 0)), 0)::numeric(12,2) as amount
FROM expenses
WHERE store_id = $1
    AND expense_date BETWEEN $2 AND $3
GROUP BY category
ORDER BY amount DESC
`

type GetExpenseReportByCategoryParams struct {
	StoreID       int64       `db:"store_id" json:"store_id"`
	ExpenseDate   pgtype.Date `db:"expense_date" json:"expense_date"`
	ExpenseDate_2 pgtype.Date `db:"expense_date_2" json:"expense_date_2"`
}

type GetExpenseReportByCategoryRow struct {
	Category string         `db:"category" json:"category"`
	Count    int64          `db:"count" json:"count"`
	Amount   pgtype.Numeric `db:"amount" json:"amount"`
}

func (q *Queries) GetExpenseReportByCategory(ctx context.Context, arg GetExpenseReportByCategoryParams) ([]GetExpenseReportByCategoryRow, error) {
	rows, err := q.db.Query(ctx, getExpenseReportByCategory, arg.StoreID, arg.ExpenseDate, arg.ExpenseDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetExpenseReportByCategoryRow{}
	for rows.Next() {
		var i GetExpenseReportByCategoryRow
		if err := rows.Scan(&i.Category, &i.Count, &i.Amount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpenseReportByPayer = `-- name: GetExpenseReportByPayer :many
SELECT
    e.payer_id,
    su.username as payer_name,
    COUNT(*) as advance_count,
    COALESCE(SUM(e.amount + COALESCE(e.other_fee, 0)), 0)::numeric(12,2) as advance_amount,
    COALESCE(SUM(CASE WHEN e.is_reimbursed = true THEN e.amount + COALESCE(e.other_fee, 0) ELSE 0 END), 0)::numeric(12,2) as reimbursed_amount
FROM expenses e
LEFT JOIN staff_users su ON e.payer_id = su.id
WHERE e.store_id = $1
    AND e.expense_date BETWEEN $2 AND $3
    AND e.payer_id IS NOT NULL
GROUP BY e.payer_id, su.username
ORDER BY advance_amount DESC
`

type GetExpenseReportByPayerParams struct {
	StoreID       int64       `db:"store_id" json:"store_id"`
	ExpenseDate   pgtype.Date `db:"expense_date" json:"expense_date"`
	ExpenseDate_2 pgtype.Date `db:"expense_date_2" json:"expense_date_2"`
}

type GetExpenseReportByPayerRow struct {
	PayerID          pgtype.Int8    `db:"payer_id" json:"payer_id"`
	PayerName        pgtype.Text    `db:"payer_name" json:"payer_name"`
	AdvanceCount     int64          `db:"advance_count" json:"advance_count"`
	AdvanceAmount    pgtype.Numeric `db:"advance_amount" json:"advance_amount"`
	ReimbursedAmount pgtype.Numeric `db:"reimbursed_amount" json:"reimbursed_amount"`
}

func (q *Queries) GetExpenseReportByPayer(ctx context.Context, arg GetExpenseReportByPayerParams) ([]GetExpenseReportByPayerRow, error) {
	rows, err := q.db.Query(ctx, getExpenseReportByPayer, arg.StoreID, arg.ExpenseDate, arg.ExpenseDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetExpenseReportByPayerRow{}
	for rows.Next() {
		var i GetExpenseReportByPayerRow
		if err := rows.Scan(
			&i.PayerID,
			&i.PayerName,
			&i.AdvanceCount,
			&i.AdvanceAmount,
			&i.ReimbursedAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpenseReportBySupplier = `-- name: GetExpenseReportBySupplier :many
SELECT
    e.supplier_id,
    s.name as supplier_name,
    COUNT(*) as count,
    COALESCE(SUM(e.amount + COALESCE(e.other_fee, 0)), 0)::numeric(12,2) as amount
FROM expenses e
LEFT JOIN suppliers s ON e.supplier_id = s.id
WHERE e.store_id = $1
    AND e.expense_date BETWEEN $2 AND $3
    AND e.supplier_id IS NOT NULL
GROUP BY e.supplier_id, s.name
ORDER BY amount DESC
`

type GetExpenseReportBySupplierParams struct {
	StoreID       int64       `db:"store_id" json:"store_id"`
	ExpenseDate   pgtype.Date `db:"expense_date" json:"expense_date"`
	ExpenseDate_2 pgtype.Date `db:"expense_date_2" json:"expense_date_2"`
}

type GetExpenseReportBySupplierRow struct {
	SupplierID   pgtype.Int8    `db:"supplier_id" json:"supplier_id"`
	SupplierName pgtype.Text    `db:"supplier_name" json:"supplier_name"`
	Count        int64          `db:"count" json:"count"`
	Amount       pgtype.Numeric `db:"amount" json:"amount"`
}

func (q *Queries) GetExpenseReportBySupplier(ctx context.Context, arg GetExpenseReportBySupplierParams) ([]GetExpenseReportBySupplierRow, error) {
	rows, err := q.db.Query(ctx, getExpenseReportBySupplier, arg.StoreID, arg.ExpenseDate, arg.ExpenseDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetExpenseReportBySupplierRow{}
	for rows.Next() {
		var i GetExpenseReportBySupplierRow
		if err := rows.Scan(
			&i.SupplierID,
			&i.SupplierName,
			&i.Count,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpenseReportSummary = `-- name: GetExpenseReportSummary :one
SELECT
    COUNT(*) as total_count,
    COALESCE(SUM(amount + COALESCE(other_fee, 0)), 0)::numeric(12,2) as total_amount,
    COALESCE(SUM(CASE WHEN payer_id IS NOT NULL THEN amount + COALESCE(other_fee, 0) ELSE 0 END), 0)::numeric(12,2) as advance_amount,
    COALESCE(SUM(CASE WHEN payer_id IS NOT NULL AND is_reimbursed = true THEN amount + COALESCE(other_fee, 0) ELSE 0 END), 0)::numeric(12,2) as reimbursed_amount
FROM expenses
WHERE store_id = $1
    AND expense_date BETWEEN $2 AND $3
`

type GetExpenseReportSummaryParams struct {
	StoreID       int64       `db:"store_id" json:"store_id"`
	ExpenseDate   pgtype.Date `db:"expense_date" json:"expense_date"`
	ExpenseDate_2 pgtype.Date `db:"expense_date_2" json:"expense_date_2"`
}

type GetExpenseReportSummaryRow struct {
	TotalCount       int64          `db:"total_count" json:"total_count"`
	TotalAmount      pgtype.Numeric `db:"total_amount" json:"total_amount"`
	AdvanceAmount    pgtype.Numeric `db:"advance_amount" json:"advance_amount"`
	ReimbursedAmount pgtype.Numeric `db:"reimbursed_amount" json:"reimbursed_amount"`
}

func (q *Queries) GetExpenseReportSummary(ctx context.Context, arg GetExpenseReportSummaryParams) (GetExpenseReportSummaryRow, error) {
	row := q.db.QueryRow(ctx, getExpenseReportSummary, arg.StoreID, arg.ExpenseDate, arg.ExpenseDate_2)
	var i GetExpenseReportSummaryRow
	err := row.Scan(
		&i.TotalCount,
		&i.TotalAmount,
		&i.AdvanceAmount,
		&i.ReimbursedAmount,
	)
	return i, err
}

const getStoreExpenseByID = `-- name: GetStoreExpenseByID :one
SELECT
    e.id,
    e.supplier_id,
    COALESCE(s.name, '') AS supplier_name,
    e.payer_id,
    COALESCE(su.username, '') AS payer_name,
    e.category,
    e.amount,
    e.other_fee,
    e.expense_date,
    e.note,
    e.is_reimbursed,
    e.reimbursed_at,
    COALESCE(su2.username, '') AS updater,
    e.created_at,
    e.updated_at
FROM expenses e
LEFT JOIN suppliers s ON e.supplier_id = s.id
LEFT JOIN staff_users su ON e.payer_id = su.id
LEFT JOIN staff_users su2 ON e.updater = su2.id
WHERE e.id = $1 AND e.store_id = $2
`

type GetStoreExpenseByIDParams struct {
	ID      int64 `db:"id" json:"id"`
	StoreID int64 `db:"store_id" json:"store_id"`
}

type GetStoreExpenseByIDRow struct {
	ID           int64              `db:"id" json:"id"`
	SupplierID   pgtype.Int8        `db:"supplier_id" json:"supplier_id"`
	SupplierName string             `db:"supplier_name" json:"supplier_name"`
	PayerID      pgtype.Int8        `db:"payer_id" json:"payer_id"`
	PayerName    string             `db:"payer_name" json:"payer_name"`
	Category     pgtype.Text        `db:"category" json:"category"`
	Amount       pgtype.Numeric     `db:"amount" json:"amount"`
	OtherFee     pgtype.Numeric     `db:"other_fee" json:"other_fee"`
	ExpenseDate  pgtype.Date        `db:"expense_date" json:"expense_date"`
	Note         pgtype.Text        `db:"note" json:"note"`
	IsReimbursed pgtype.Bool        `db:"is_reimbursed" json:"is_reimbursed"`
	ReimbursedAt pgtype.Timestamptz `db:"reimbursed_at" json:"reimbursed_at"`
	Updater      string             `db:"updater" json:"updater"`
	CreatedAt    pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetStoreExpenseByID(ctx context.Context, arg GetStoreExpenseByIDParams) (GetStoreExpenseByIDRow, error) {
	row := q.db.QueryRow(ctx, getStoreExpenseByID, arg.ID, arg.StoreID)
	var i GetStoreExpenseByIDRow
	err := row.Scan(
		&i.ID,
		&i.SupplierID,
		&i.SupplierName,
		&i.PayerID,
		&i.PayerName,
		&i.Category,
		&i.Amount,
		&i.OtherFee,
		&i.ExpenseDate,
		&i.Note,
		&i.IsReimbursed,
		&i.ReimbursedAt,
		&i.Updater,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateStoreExpenseAmount = `-- name: UpdateStoreExpenseAmount :exec
UPDATE expenses SET amount = $1, updater = $2, updated_at = NOW() WHERE id = $3
`

type UpdateStoreExpenseAmountParams struct {
	Amount  pgtype.Numeric `db:"amount" json:"amount"`
	Updater pgtype.Int8    `db:"updater" json:"updater"`
	ID      int64          `db:"id" json:"id"`
}

func (q *Queries) UpdateStoreExpenseAmount(ctx context.Context, arg UpdateStoreExpenseAmountParams) error {
	_, err := q.db.Exec(ctx, updateStoreExpenseAmount, arg.Amount, arg.Updater, arg.ID)
	return err
}
