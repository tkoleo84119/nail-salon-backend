// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: service.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkServiceNameExistsExcluding = `-- name: CheckServiceNameExistsExcluding :one
SELECT EXISTS(
    SELECT 1 FROM services
    WHERE name = $1 AND id != $2
) AS exists
`

type CheckServiceNameExistsExcludingParams struct {
	Name string `db:"name" json:"name"`
	ID   int64  `db:"id" json:"id"`
}

func (q *Queries) CheckServiceNameExistsExcluding(ctx context.Context, arg CheckServiceNameExistsExcludingParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkServiceNameExistsExcluding, arg.Name, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createService = `-- name: CreateService :one
INSERT INTO services (
    id,
    name,
    price,
    duration_minutes,
    is_addon,
    is_visible,
    is_active,
    note
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, name, price, duration_minutes, is_addon, is_visible, is_active, note, created_at, updated_at
`

type CreateServiceParams struct {
	ID              int64          `db:"id" json:"id"`
	Name            string         `db:"name" json:"name"`
	Price           pgtype.Numeric `db:"price" json:"price"`
	DurationMinutes int32          `db:"duration_minutes" json:"duration_minutes"`
	IsAddon         pgtype.Bool    `db:"is_addon" json:"is_addon"`
	IsVisible       pgtype.Bool    `db:"is_visible" json:"is_visible"`
	IsActive        pgtype.Bool    `db:"is_active" json:"is_active"`
	Note            pgtype.Text    `db:"note" json:"note"`
}

func (q *Queries) CreateService(ctx context.Context, arg CreateServiceParams) (Service, error) {
	row := q.db.QueryRow(ctx, createService,
		arg.ID,
		arg.Name,
		arg.Price,
		arg.DurationMinutes,
		arg.IsAddon,
		arg.IsVisible,
		arg.IsActive,
		arg.Note,
	)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.DurationMinutes,
		&i.IsAddon,
		&i.IsVisible,
		&i.IsActive,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getServiceByID = `-- name: GetServiceByID :one
SELECT id, name, price, duration_minutes, is_addon, is_visible, is_active, note, created_at, updated_at FROM services WHERE id = $1 LIMIT 1
`

func (q *Queries) GetServiceByID(ctx context.Context, id int64) (Service, error) {
	row := q.db.QueryRow(ctx, getServiceByID, id)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.DurationMinutes,
		&i.IsAddon,
		&i.IsVisible,
		&i.IsActive,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getServiceByIds = `-- name: GetServiceByIds :many
SELECT
    id,
    name,
    price,
    duration_minutes,
    is_addon,
    is_visible,
    is_active,
    note
FROM services
WHERE id = ANY($1::bigint[])
`

type GetServiceByIdsRow struct {
	ID              int64          `db:"id" json:"id"`
	Name            string         `db:"name" json:"name"`
	Price           pgtype.Numeric `db:"price" json:"price"`
	DurationMinutes int32          `db:"duration_minutes" json:"duration_minutes"`
	IsAddon         pgtype.Bool    `db:"is_addon" json:"is_addon"`
	IsVisible       pgtype.Bool    `db:"is_visible" json:"is_visible"`
	IsActive        pgtype.Bool    `db:"is_active" json:"is_active"`
	Note            pgtype.Text    `db:"note" json:"note"`
}

func (q *Queries) GetServiceByIds(ctx context.Context, dollar_1 []int64) ([]GetServiceByIdsRow, error) {
	rows, err := q.db.Query(ctx, getServiceByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetServiceByIdsRow{}
	for rows.Next() {
		var i GetServiceByIdsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.DurationMinutes,
			&i.IsAddon,
			&i.IsVisible,
			&i.IsActive,
			&i.Note,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceByName = `-- name: GetServiceByName :one
SELECT id, name, price, duration_minutes, is_addon, is_visible, is_active, note, created_at, updated_at FROM services WHERE name = $1 LIMIT 1
`

func (q *Queries) GetServiceByName(ctx context.Context, name string) (Service, error) {
	row := q.db.QueryRow(ctx, getServiceByName, name)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.DurationMinutes,
		&i.IsAddon,
		&i.IsVisible,
		&i.IsActive,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getServiceDetailById = `-- name: GetServiceDetailById :one
SELECT
    id,
    name,
    price,
    duration_minutes,
    is_addon,
    is_visible,
    is_active,
    note
FROM services
WHERE id = $1
`

type GetServiceDetailByIdRow struct {
	ID              int64          `db:"id" json:"id"`
	Name            string         `db:"name" json:"name"`
	Price           pgtype.Numeric `db:"price" json:"price"`
	DurationMinutes int32          `db:"duration_minutes" json:"duration_minutes"`
	IsAddon         pgtype.Bool    `db:"is_addon" json:"is_addon"`
	IsVisible       pgtype.Bool    `db:"is_visible" json:"is_visible"`
	IsActive        pgtype.Bool    `db:"is_active" json:"is_active"`
	Note            pgtype.Text    `db:"note" json:"note"`
}

func (q *Queries) GetServiceDetailById(ctx context.Context, id int64) (GetServiceDetailByIdRow, error) {
	row := q.db.QueryRow(ctx, getServiceDetailById, id)
	var i GetServiceDetailByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.DurationMinutes,
		&i.IsAddon,
		&i.IsVisible,
		&i.IsActive,
		&i.Note,
	)
	return i, err
}
